## 动态规划算法

### 适用问题

动态规划算法，适用于有**重叠子问题**和有**最优子结构**性质的问题。将问题化解为重复子问题，找到子问题的最优解，从而得到原问题的最优解。动态规划算法视图解决每一个子问题，一旦某个子问题已解决，会将其结果**记忆存储**，再次使用时将通过缓存而不是重新计算，从而减少计算量。

1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，那么称这个问题具有最优子结构性质。也可以理解为问题的最优解是由其子问题的最优解组成的。所以得到所有子问题的最优解，就能得到问题的最优解。
2. 无后效性。子问题相互独立，解决的子问题就不会再改变，也不受在该问题之后的、包含它的更大问题的求解所影响。即如果求某个上层问题的最优解，要求其子问题使用非最优解，这就不符合无后效性，或者说问题并不能由子问题的最优解进行表达。
3. 子问题重叠性。从上到下的递归过程中，每次产生的子问题，并不总是新问题，有些子问题会被重复计算多次。对于多次计算的子问题采用结果缓存，再次遇到时，即子问题重叠时，通过读取缓存来减少计算量。虽然是子问题的枚举过程，缓存能够减少枚举过程中的重复运算部分。

### 动态规划算法中的基本概念

1. 阶段：一个活动过程可以分为若干个相互关联的阶段，每一个阶段可以认为是采取相应决策的动作，每个阶段相互联系，所以一个阶段的决策确定后将会对下一个阶段的可决策内容产生影响，从而影响下一个阶段的最后决策。每个阶段会有多种决策，多阶段决策就会有多种决策组合，这种问题成为多阶段决策问题。连续的阶段产生的确定的决策序列，成为该问题的一个策略，而动态规划就是要在阶段进行过程中找到最优解。最优子结构性质，使得每一个阶段选择最佳策略，就能在最后得到整个问题的最佳策略。
2. 状态：每个阶段开始时，都会有不可控的客观条件，比如出发位置，必须有上一个阶段的到达位置决定。而阶段从开始到结束，可能会有很多决策，对应不同的状态变化，通常来说状态转移是离散的。状态转移可以是线性的，也可以是多个分量的（多种维度的选择），每个阶段的状态可以有不同多的分量。**当过程按所有可能不同的方式发展时，过程各段的状态变量将在某一确定的范围内取值。状态变量取值的集合称为状态集合**。
3. 无后效性：可以用动态规划解决的问题必须要有无后效性，上面也提到过基本性质。用阶段的表述，可以认为是阶段的某一状态，在之后的每个阶段运行过程中都不收影响，只有这样才能有确定的策略。简单来说就是状态转移的影响是单向的。
4. 决策：一个阶段结束后，得到一个确定的状态，下一个阶段中，这个状态可以演化为其他状态，在这个阶段中选择一种状态转移，就是决策。线性动态规划中，由于状态转移是线性的，所以通常可以用一维数组来记录决策的过程。如果用树形结构来记录每个阶段可能发生的所有状态转移，那么每个阶段对应的决策组成的记录，将成为这棵树中的一条从根节点到叶子节点的路径。每个阶段的决策应当只考虑当前的可选的状态转移，保证无后效性。
5. 策略：每个阶段的决策构成的序列构成一个完整的解决问题的策略。对于多阶段决策过程来说，策略一定是有穷的。所有策略中满足条件的就是最有策略。
6. 转移方程：直接用数学语言表达比较明确。阶段k的状态为x(k)，阶段k+1的状态应该是x(k+1)，那么x(k+1)应当由x(k)和阶段k的决策u(k)来确定，所以我们用关系T来表达，得到x(k+1)=T(x(k),u(k))，这就是普适性的描述--k阶段的状态转移到k+1阶段的转移规律，即状态转移方程。
7. 最优化原理：一个拥有n阶段的问题，对于前i阶段所确定的状态，后n-i阶段的子策略需要时最优的。极限来说当i=0时，就是最优策略。所以最优化原理，其实描述的是一个问题要有最优子结构性质。对于一个策略来说，整个转移过程，局部来看也应当满足整个问题的最优要求。比如最短路径序列，其中任意两个节点之间的子路径序列，也应当是最优的。

### 动态规划的分类

动态规划按照状态排布情况分为以下几种：

1. 线性动态规划：状态转移是线性的，比如最短路径，每次决策都是选择最短路径，比较的数据是一维线性的。再比如过河问题，每次决策的是过河的时间。
2. 区域动态规划：状态通常有两个维度，所以状态要表示为d\[i]\[j]，表达区间\[i,j]上的最优解。分别作i方向上和j方向上的最优解，最优确定一个区域。例如：给定长度为n的字符串A，求插入最少字符使其成为回文序列。这个问题有明显的重叠子结构特种，如果子字符串X是回文序列，那么‘aXa'也是回文序列。字符串A的一个子串，可以表达为A\[i,j]，即字符串A中i位置到j位置形成的子串。如果用d\[i]\[j]来表示这个子串所需要的最少字符串，那么当A[i]=A[j]时，d\[i]\[j]=d\[i+1]\[j-1]。即A[i,j]和A\[i+1,j-1]所需要的字符数量相同。由于有两个维度，所以决策时候就包含两个方向，A[j]后面增加一个字符A[i]，或者A[i]前增加一个字符A[j]，这样不用两头都增加。所以状态转移方程d\[i]\[j]=min{d\[i+1][j],d\[i]\[j-1]} + 1。是一种从两头往中间缩，逐渐累加出最小所需的结果。时间复杂度是O(n^2)。
3. 树形动态规划：这里不做详细的介绍，典型的有二分查找树。简单来说就是在一个树形结构上进行动态规划，决策的特点就是有两个方向，从叶向根，或者根向叶。线性动态规划一般是循环，树形动态规划基本要借助递归
4. 背包问题：也是动态规划的代表性问题，可以认为是在加权图结构上进行动态规划，暂时不做详细介绍。

### 动态规划的思路过程

#### 递推

递推的过程可以说是动态规划的起点，状态转移函数的推导过程其实就是依赖递推。那么来看一个简单的递推例子：

> 对一个“01”串进行一次X变换被定义为：将其中的"0"变成"10"，"1"变成"01"，初始串为"1"，求经过N(N <= 1000)次X变换后的串中有多少对"00"。

试着按照变换写上几次变换结果：【1，01，1001，01101001，...】由于01->1001的过程是0->10和1->01两个变换的和，所有将01->1001这一子变换视作能产生“00”的过程，所以将过程压缩，令A="10"、B="01"，我们要求经过N次变化后AB出现的次数。如果说FA[i]表示A经过i次X变换后“00”的数量，显然边界条件FA[0]=0。同理有FB[i]。初始串为“1”，那么可以认为是从B开始：【B，AB，BAAB，ABBABAAB，...】不难发现B的变换结果是AB，所以B的右节点一定是B，而A的右节点一定是A，在递推一下，A的左子树无论多少层，最右节点都是B，所以A的左右子树无论多少层合并时中间不会有AB出现，所以A的两个子树是两个子结构，不相互影响，那么就可以得到FA(i)=FB(i-1)+FA(i-1)，即以A为根节点的子树，可以分解成i-1变换的左B子树+i-1次变换的右A子树的和。那么相应的B节点的左子树无论多少层，最右端点一定是A，右子树的左端点是BABA交替，所以每隔一层，左子树的最右端点，都将和右子树的最左端点形成一个AB，那么FB(i)=FA(i-1)+FB(i-1)+(i mod 2)。由于起始串是“1”，执行N次变换，就是B执行N-1次变换，即求FB(N-1)，利用两个递推关系，最终可以得到答案。

#### 记忆

从递推关系式中，或者说递归函数调用，不难发现当前调用依赖递归调用的值计算当前调用的答案，即算出i-1次的结果，才能算i的结果。而动态规划问题的子问题重叠性，在运算过程中会遇到已经运算过的子问题结果，因此在递归的过程中需要增加一个缓存，往往在多维递推的时候更加有效。

#### 状态转移

把一个问题中的“状态”抽取出来，是利用动态规划解决问题的关键之一。比如递推中的例子，FA(i)表示经过I次变换，以A为根节点的子树生成的串中，目标的数量。状态转移就是找递推关系

#### 最优子结构

动态规划的一个基本原则就是问题拥有最优子结构，递归调用相当于求子问题的解，调用返回相当于合并子问题的解。然而证明问题能够划分最优子结构，是需要一定的数学和逻辑基础。网上抄来的例子：

> 最长单调子序列：给定一个长度为n(1 <= n <= 1000)的整数序列a[i]，求它的一个子序列(子序列即在原序列任意位置删除0或多个元素后的序列)，满足如下条件**：**
>
> ​      1、该序列单调递增；
>
> ​      2、在所有满足条件1的序列中长度是最长的；

最长单调子序列是非常经典的动态规划问题，首先用枚举法DFS的思想去尝试。针对每一个元素，递归探测之后的每个数，复杂度是指数级的。

假如我们有序列[1,2,3,3,5,0,1]

策略1：取a[0]=1，取a[1]=2，取a[2]=3，不取a[3]=3（不单调递增）,取a[4]=5，不取a[5]=0，不取a[6]=1。得到最长子序列[1,2,3,5]，长度为4。

策略2：取a[0]=1，不取a[1]=2（相当于第二阶段的另一个决策），取a[2]=3，...后面就不列举了。得到的序列应该是[1,3,5]，长度为3。

对于每个元素都有取和不取两个选择，只列举这两种情况来分析。其实过程中我们会得到不同的子序列，比如策略1中，[1],[1,2],[1,2,3],[1,2,3],[1,2,3,5]...，从而最终得到[1,2,3,5]这个序列。如果我们用d[i]表示a[i]结尾的最长子序列，显然任意比d[i]元素少的序列，长度都将小于d[i]。因此d[0]=1,d[1]=2,d[2]=3,d[3]=3...，那么有**d[i] = max{ d[j] | j < i && a[j] < a[i] } + 1**这样的递推关系。d[j]是d[i]的子问题最优解，当且仅当d[j]是最优的才能得到d[i]是最优解。由于这个特性，在策略2的过程中，第三步就可以不取了。策略1中我们记录了一组d[i]，策略2的过程中，肯定会依次比较用于更新，当i=2时，策略1得到的d[2]=3，而策略2由于舍掉了a[1]，所以必然不会得到更长的序列，d[2]'<d[2]，再往后也没法更长了，所以就可以停止了。所以其他的策略中，都会根据已有的d[i]进行选择性平移，将指数级别平铺到线性级别。

#### 无后效性

决策使得状态改变发生状态转移，无后效性就要求决策只针对当前阶段的起始状态，并且不依赖历史状态进行状态转移。

### 常用的状态转移方程

动态规划的三要素：

> 1. 所有不同的子问题列成的表
> 2. 解决问题的依赖关系（可以看成是一张图）
> 3. 填充子问题的顺序（对解决问题的依赖关系图进行拓扑排序，即装填转移图）

如果一个问题的子问题数量是O(n^t)级别，每个子问题依赖O(n^e)级别的结果，这个问题可以称为tD/eD问题。

#### 第一类1D/1D问题

即n个子问题，每个子问题仍要依赖n个子问题的解，或者说递推关系是i和i-1的关系，比如最长子序列问题。通常可以用这样的转移方程：

**d[i] = opt{ d[j] + w(j, i) | 0 <= i < j } (1 <= i <= n)**

其中opt通常是min或max函数，用于不断更新最优解；w(j,i)表示是一个实函数，通常表示区间值，求最长单调子序列时，这个值根据问题的具体情况，是可以没有的。通常w(j,i)表示的是i和j的递推关系中存在的一个常数，相当于线性关系中的一个偏移量，或者纵轴截距等。

#### 第二类2D/0D问题

即n^2个子问题，但是每个子问题只依赖1个子问题的解，通常是区域动态规划问题，最长公共子序列属于这一类问题，通常转移方程是这样的：

**d\[i][j] = opt{ d\[i-1][j] + xi, d\[i][j-1] + yj, d\[i-1][j-1] + zij }     (1<= i, j <= n)**



用动态规划的思想分析一个问题，从动态规划的特性出发：

1. 确定问题的决策对象，考虑无后效性。
2. 划分阶段
3. 确定状态变量
4. 根据状态变量确定费用函数和目标函数
5. 确定转移方程